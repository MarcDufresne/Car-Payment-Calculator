// Simplified Alpine.js-like implementation for Car Calculator
(function() {
    'use strict';
    
    let globalData = null;
    
    const Alpine = {
        start() {
            if (document.readyState === 'loading') {
                document.addEventListener('DOMContentLoaded', () => this.init());
            } else {
                this.init();
            }
        },
        
        init() {
            const dataElements = document.querySelectorAll('[x-data]');
            dataElements.forEach(element => {
                const dataAttr = element.getAttribute('x-data');
                if (dataAttr && window[dataAttr.replace('()', '')]) {
                    const dataFn = window[dataAttr.replace('()', '')];
                    this.initComponent(element, dataFn());
                }
            });
        },
        
        initComponent(element, data) {
            globalData = data;
            
            // Store update function for reactivity
            const updateBindings = () => {
                this.updateAllBindings(element, data);
            };
            
            // Initialize x-model bindings
            element.querySelectorAll('[x-model]').forEach(input => {
                const modelAttr = input.getAttribute('x-model');
                const isNumber = modelAttr.includes('.number');
                const prop = modelAttr.replace('.number', '');
                
                // Set initial value
                if (data[prop] !== undefined) {
                    input.value = data[prop];
                }
                
                // Listen for input changes
                input.addEventListener('input', (e) => {
                    data[prop] = isNumber ? (parseFloat(e.target.value) || 0) : e.target.value;
                    if (data.saveToStorage) data.saveToStorage();
                    setTimeout(updateBindings, 0); // Async update
                });
            });
            
            // Initialize @click bindings
            element.querySelectorAll('[\\@click]').forEach(el => {
                const expr = el.getAttribute('@click');
                el.addEventListener('click', () => {
                    this.evaluate(expr, data);
                    setTimeout(updateBindings, 0);
                });
            });
            
            // Initialize radio button bindings for x-model
            element.querySelectorAll('input[type="radio"][x-model]').forEach(radio => {
                const prop = radio.getAttribute('x-model');
                const value = radio.getAttribute('value');
                
                // Set initial checked state
                radio.checked = (data[prop] === value);
                
                radio.addEventListener('change', () => {
                    if (radio.checked) {
                        data[prop] = value;
                        if (data.saveToStorage) data.saveToStorage();
                        setTimeout(updateBindings, 0);
                    }
                });
            });
            
            // Initialize checkbox bindings for arrays
            element.querySelectorAll('input[type="checkbox"][x-model]').forEach(checkbox => {
                const modelAttr = checkbox.getAttribute('x-model');
                const value = parseFloat(checkbox.getAttribute('value')) || checkbox.getAttribute('value');
                
                // Handle array model
                if (Array.isArray(data[modelAttr])) {
                    checkbox.checked = data[modelAttr].includes(value);
                    
                    checkbox.addEventListener('change', () => {
                        if (checkbox.checked) {
                            if (!data[modelAttr].includes(value)) {
                                data[modelAttr].push(value);
                            }
                        } else {
                            const index = data[modelAttr].indexOf(value);
                            if (index > -1) {
                                data[modelAttr].splice(index, 1);
                            }
                        }
                        if (data.saveToStorage) data.saveToStorage();
                        setTimeout(updateBindings, 0);
                    });
                } else {
                    // Handle boolean model
                    checkbox.checked = data[modelAttr];
                    checkbox.addEventListener('change', () => {
                        data[modelAttr] = checkbox.checked;
                        if (data.saveToStorage) data.saveToStorage();
                        setTimeout(updateBindings, 0);
                    });
                }
            });
            
            // Process x-for templates
            element.querySelectorAll('template[x-for]').forEach(template => {
                this.processXFor(template, data, updateBindings);
            });
            
            // Call init if exists
            if (data.init) {
                data.init();
            }
            
            // Initial update
            this.updateAllBindings(element, data);
        },
        
        processXFor(template, data, updateBindings) {
            const forExpr = template.getAttribute('x-for');
            const [itemName, arrayName] = forExpr.split(' in ').map(s => s.trim());
            const keyAttr = template.getAttribute(':key') || 'index';
            
            const renderList = () => {
                const array = this.evaluate(arrayName, data) || [];
                const parent = template.parentNode;
                
                // Remove existing items
                const existingItems = parent.querySelectorAll('[data-x-for-item]');
                existingItems.forEach(item => item.remove());
                
                // Render new items
                array.forEach((item, index) => {
                    const itemData = { ...data, [itemName]: item, index };
                    const clone = template.content.cloneNode(true);
                    
                    // Process bindings in the cloned content
                    this.processClonedBindings(clone, itemData);
                    
                    // Wrap in container
                    const wrapper = document.createElement('div');
                    wrapper.setAttribute('data-x-for-item', '');
                    wrapper.appendChild(clone);
                    parent.insertBefore(wrapper, template);
                });
            };
            
            // Initial render
            renderList();
            
            // Setup reactive rendering (simplified)
            const originalArray = this.evaluate(arrayName, data);
            if (originalArray && Array.isArray(originalArray)) {
                // Monkey patch array methods for reactivity
                ['push', 'pop', 'shift', 'unshift', 'splice', 'sort', 'reverse'].forEach(method => {
                    const original = originalArray[method];
                    originalArray[method] = function(...args) {
                        const result = original.apply(this, args);
                        setTimeout(renderList, 0);
                        return result;
                    };
                });
            }
        },
        
        processClonedBindings(clone, data) {
            // Process x-text
            clone.querySelectorAll('[x-text]').forEach(el => {
                const expr = el.getAttribute('x-text');
                el.textContent = this.evaluate(expr, data);
            });
            
            // Process :id
            clone.querySelectorAll('[\\:id]').forEach(el => {
                const expr = el.getAttribute(':id');
                el.id = this.evaluate(expr, data);
            });
            
            // Process :for
            clone.querySelectorAll('[\\:for]').forEach(el => {
                const expr = el.getAttribute(':for');
                el.setAttribute('for', this.evaluate(expr, data));
            });
            
            // Process :value
            clone.querySelectorAll('[\\:value]').forEach(el => {
                const expr = el.getAttribute(':value');
                el.value = this.evaluate(expr, data);
            });
            
            // Process :class
            clone.querySelectorAll('[\\:class]').forEach(el => {
                const expr = el.getAttribute(':class');
                const value = this.evaluate(expr, data);
                if (value) el.className = value;
            });
        },
        
        updateAllBindings(element, data) {
            // Update x-text
            element.querySelectorAll('[x-text]').forEach(el => {
                const expr = el.getAttribute('x-text');
                try {
                    el.textContent = this.evaluate(expr, data);
                } catch (e) {
                    console.error('x-text error:', expr, e);
                }
            });
            
            // Update x-html
            element.querySelectorAll('[x-html]').forEach(el => {
                const expr = el.getAttribute('x-html');
                try {
                    el.innerHTML = this.evaluate(expr, data);
                } catch (e) {
                    console.error('x-html error:', expr, e);
                }
            });
            
            // Update x-show
            element.querySelectorAll('[x-show]').forEach(el => {
                const expr = el.getAttribute('x-show');
                try {
                    const show = this.evaluate(expr, data);
                    el.style.display = show ? '' : 'none';
                } catch (e) {
                    console.error('x-show error:', expr, e);
                }
            });
            
            // Update :class
            element.querySelectorAll('[\\:class]').forEach(el => {
                const expr = el.getAttribute(':class');
                try {
                    const className = this.evaluate(expr, data);
                    if (className) el.className = className;
                } catch (e) {
                    console.error(':class error:', expr, e);
                }
            });
        },
        
        evaluate(expr, data) {
            try {
                const keys = Object.keys(data);
                const values = Object.values(data);
                const func = new Function(...keys, `return ${expr}`);
                return func(...values);
            } catch (e) {
                console.error('Evaluation error:', expr, e);
                return '';
            }
        }
    };
    
    window.Alpine = Alpine;
    Alpine.start();
})();